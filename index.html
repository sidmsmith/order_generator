<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <!-- Version: v1.4.7 - Added Vercel Analytics -->
  <title>Order Generator v1.4.7</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- CodeMirror for JSON syntax highlighting with folding support -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.css">
  <!-- Load CodeMirror scripts asynchronously to not block authentication -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js" defer></script>
  <!-- JSON mode is part of JavaScript mode, so we don't need a separate json.min.js file -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldcode.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/brace-fold.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/indent-fold.min.js" defer></script>
  <style>
    /* Dark Theme (Default) */
    :root {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
    }
    
    /* Manhattan Theme */
    :root.theme-manhattan {
      --bg-dark: rgb(45, 47, 59);
      --card-bg: #484e5e;
      --input-bg: #282c34;
      --border: #333;
      --text: #495057;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: hsl(142.1 76.2% 36.3%);
      --primary: #3B82F6;
      --secondary: #6c757d;
      --shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    body { 
      background: var(--bg-dark); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      min-height: 100vh;
      margin: 0;
    }

    .main-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 1.5rem;
      margin: 1rem;
      display: flex;
      flex-direction: column;
    }

    @media (min-width: 769px) {
      .main-card { max-width: 900px; margin: 2rem auto; }
    }

    .form-control, .form-select, textarea {
      background: var(--input-bg);
      border: 1px solid #444;
      color: #fff;
      border-radius: 8px;
    }
    .form-control:focus, .form-select:focus, textarea:focus {
      background: #333;
      border-color: var(--primary);
      box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
      color: #fff;
    }

    .btn-primary { background: var(--primary); border: none; }
    .btn-success { background: var(--success); border: none; }
    .btn-secondary { background: #6c757d; border: none; }
    .btn-primary:hover { background: #0b5ed7; }
    .btn-success:hover { background: #218838; }
    .btn-secondary:hover { background: #5a6268; }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 1rem 0 0.5rem 0;
      min-height: 2rem;
    }
    .status { 
      font-weight: 600; 
      padding: 0.25rem 0;
      flex: 1;
    }

    .form-label { color: #bbbbbb; font-weight: 600; }
    small { color: #999; }
    h2 { color: var(--primary); }

    /* Theme-specific text colors */
    :root.theme-manhattan .form-label { color: #bbbbbb; }
    :root.theme-manhattan small { color: #999; }
    
    /* Theme selector gear icon - always white */
    .theme-selector-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: #ffffff !important; /* Always white */
      padding: 0.5rem;
      cursor: pointer;
      font-size: 1.5rem;
      z-index: 1000;
      transition: opacity 0.2s, transform 0.3s ease;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .theme-selector-btn:hover {
      opacity: 0.7;
      transform: rotate(90deg);
    }
    
    /* Modal styling */
    .modal-content {
      background: var(--card-bg) !important;
      border: 1px solid var(--border) !important;
      color: var(--text) !important;
    }
    .modal-header {
      border-bottom: 1px solid var(--border) !important;
      background: var(--card-bg) !important;
    }
    .modal-header .modal-title {
      color: var(--text) !important;
    }
    .modal-body {
      background: var(--card-bg) !important;
      color: var(--text) !important;
    }
    .btn-close-white {
      filter: invert(1) grayscale(100%) brightness(200%);
    }

    /* HIDDEN UNTIL AUTH */
    #mainUI { display: none; }

    /* CodeMirror JSON Editor */
    .CodeMirror {
      background: var(--input-bg) !important;
      border: 1px solid var(--border);
      border-radius: 8px;
      height: 400px;
      font-size: 14px;
    }
    .CodeMirror-focused {
      border-color: var(--primary) !important;
    }

    /* Console Output */
    .console-output {
      background: #000;
      border: 1px solid #444;
      border-radius: 8px;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 0.8em;
      padding: 0.75rem;
      height: 400px;
      overflow-y: auto;
      margin-top: 1rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .console-output .error { color: #ff6b6b; }
    .console-output .success { color: #51cf66; }
    .console-output .info { color: #339af0; }

    /* Accordion styling for order lines */
    .accordion-item {
      background: var(--input-bg) !important;
      border-color: var(--border) !important;
    }

    .accordion-button {
      background: var(--input-bg) !important;
      color: var(--text) !important;
      border-color: var(--border) !important;
    }

    .accordion-button:not(.collapsed) {
      background: #333 !important;
      color: var(--primary) !important;
      box-shadow: none;
    }

    .accordion-button:focus {
      box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
    }

    .accordion-body {
      background: var(--card-bg) !important;
    }

    /* Manhattan theme: white text for collapsed accordion buttons */
    :root.theme-manhattan .accordion-button {
      color: #ffffff !important;
    }
    
    /* Manhattan theme: keep blue when expanded */
    :root.theme-manhattan .accordion-button:not(.collapsed) {
      color: var(--primary) !important;
    }

    /* Summary fields section */
    .summary-section {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <div class="main-card" style="position: relative;">
    <button class="theme-selector-btn" id="themeSelectorBtn" title="Select Theme">
      <i class="fas fa-cog"></i>
    </button>
    <h2 class="text-center mb-4">Order Generator v1.4.7</h2>

    <!-- ORG -->
    <div id="orgSection" class="mb-3">
      <label class="form-label">ORG:</label>
      <div class="d-flex align-items-center gap-2">
        <input type="text" id="org" class="form-control" placeholder="Enter ORG" maxlength="20" style="width: 250px; max-width: 100%;" />
        <button id="authBtn" class="btn btn-success px-4">Authenticate</button>
      </div>
      <small>Press Enter to authenticate</small>
    </div>

    <!-- STATUS -->
    <div class="status-bar">
      <div class="status" id="status">Enter ORG and press Enter to authenticate</div>
    </div>

    <!-- MAIN UI (Hidden until auth) -->
    <div id="mainUI">
      <!-- SAMPLE ORDER NUMBER INPUT -->
      <div class="mb-3">
        <label class="form-label">Sample Order Number:</label>
        <input type="text" id="orderNumberInput" class="form-control" placeholder="Enter order number to copy" />
        <small>Enter the order number of an existing order to load and copy</small>
      </div>

      <!-- LOAD ORDER BUTTON -->
      <div class="mb-3 d-flex align-items-center gap-3">
        <button id="loadOrderBtn" class="btn btn-success px-4" style="min-width: 200px;">Load Order</button>
        <span id="loadOrderStatus" class="text-muted" style="font-size: 0.9em;"></span>
      </div>

      <!-- SUMMARY FIELDS (Hidden until order loaded) -->
      <div id="summarySection" class="mb-3" style="display: none;">
        <label class="form-label mb-2">Order Summary (editable):</label>
        <div class="summary-section">
          <div class="row g-3">
            <div class="col-md-6">
              <label class="form-label">Order Number(s)</label>
              <input type="text" id="summaryOrderNumber" class="form-control" placeholder="Supports multiple (space/comma/semicolon) or ranges (ORDER001-ORDER007)" />
            </div>
            <div class="col-md-6">
              <label class="form-label">Order Type</label>
              <input type="text" id="summaryOrderType" class="form-control" />
            </div>
            <div class="col-md-6">
              <label class="form-label">Destination Facility</label>
              <input type="text" id="summaryDestinationFacility" class="form-control" />
            </div>
            <div class="col-md-6">
              <label class="form-label">Pickup Start Date/Time</label>
              <div class="input-group">
                <input type="datetime-local" id="summaryPickupStart" class="form-control" />
                <button type="button" class="btn btn-outline-secondary" id="pickupStartCalendarBtn" title="Open calendar">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- ORDER LINES ACCORDION (Hidden until order loaded) -->
      <div id="orderLinesSection" class="mb-3" style="display: none;">
        <label class="form-label mb-2">Order Lines (editable):</label>
        <div id="orderLinesAccordion" class="accordion">
          <!-- Order lines will be dynamically added here -->
        </div>
      </div>

      <!-- CREATE ORDER BUTTON -->
      <div id="createOrderButtonSection" class="mb-3" style="display: none;">
        <div class="d-flex align-items-center gap-3">
          <button id="createOrderBtn" class="btn btn-primary px-4" style="min-width: 200px;">Create Order(s)</button>
          <span id="createOrderStatus" class="text-muted" style="font-size: 0.9em;"></span>
        </div>
      </div>

      <!-- JSON EDITOR -->
      <div class="mb-3">
        <label class="form-label">Order JSON (editable):</label>
        <textarea id="jsonTextarea" class="form-control" style="display: none;"></textarea>
        <small>Load an order to populate this editor, then edit as needed before creating a new order</small>
      </div>


      <!-- CONSOLE OUTPUT -->
      <div class="mt-4">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <label class="form-label mb-0">API Console (Testing):</label>
          <button type="button" id="clearConsoleBtn" class="btn btn-sm btn-secondary">Clear</button>
        </div>
        <div id="consoleOutput" class="console-output" style="height: 400px; overflow-y: auto;">Ready. Authenticate and load an order to begin.</div>
      </div>
    </div>
  </div>

  <!-- THEME SELECTOR MODAL -->
  <div class="modal fade" id="themeModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Select Theme</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <div class="list-group" id="themeList"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const orgInput = document.getElementById('org');
    const authBtn = document.getElementById('authBtn');
    const orgSection = document.getElementById('orgSection');
    const mainUI = document.getElementById('mainUI');
    const statusEl = document.getElementById('status');
    const orderNumberInput = document.getElementById('orderNumberInput');
    const jsonTextarea = document.getElementById('jsonTextarea');
    const loadOrderBtn = document.getElementById('loadOrderBtn');
    const createOrderBtn = document.getElementById('createOrderBtn');
    const consoleOutput = document.getElementById('consoleOutput');
    const clearConsoleBtn = document.getElementById('clearConsoleBtn');
    const summarySection = document.getElementById('summarySection');
    const orderLinesSection = document.getElementById('orderLinesSection');
    const summaryOrderNumber = document.getElementById('summaryOrderNumber');
    const summaryOrderType = document.getElementById('summaryOrderType');
    const summaryDestinationFacility = document.getElementById('summaryDestinationFacility');
    const summaryPickupStart = document.getElementById('summaryPickupStart');
    const orderLinesAccordion = document.getElementById('orderLinesAccordion');
    const createOrderButtonSection = document.getElementById('createOrderButtonSection');

    let token = null;
    let jsonEditor = null;
    let currentOrderData = null; // Store the current order JSON object
    let parsedOrderNumbers = []; // Store parsed order numbers for bulk import
    let availableUOMs = []; // Store available UOMs

    // Ensure ORG is always blank on load (security)
    orgInput.value = '';

    // Initialize CodeMirror editor
    function initJsonEditor() {
      if (jsonEditor) return;
      
      // Check if CodeMirror is loaded, if not, use textarea fallback
      if (typeof CodeMirror === 'undefined') {
        logToConsole('CodeMirror not loaded yet, using textarea fallback', 'info');
        jsonTextarea.style.display = 'block';
        return;
      }
      
      try {
        jsonEditor = CodeMirror.fromTextArea(jsonTextarea, {
          mode: { name: "javascript", json: true },
          theme: "monokai",
          lineNumbers: true,
          indentUnit: 2,
          autoCloseBrackets: true,
          matchBrackets: true,
          lineWrapping: true,
          foldGutter: true,
          gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"]
        });
        logToConsole('CodeMirror editor initialized successfully', 'success');
      } catch (e) {
        logToConsole(`CodeMirror initialization failed: ${e.message}, using textarea fallback`, 'error');
        jsonTextarea.style.display = 'block';
      }
    }

    // ===== LOCALSTORAGE PERSISTENCE =====
    const STORAGE_KEY = 'order_generator_preferences';
    
    function savePreferences() {
      const prefs = {
        orderNumber: orderNumberInput.value
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
      } catch (e) {
        console.warn('Failed to save preferences:', e);
      }
    }
    
    function loadPreferences() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const prefs = JSON.parse(saved);
          if (prefs.orderNumber !== undefined) {
            orderNumberInput.value = prefs.orderNumber;
          }
        }
      } catch (e) {
        console.warn('Failed to load preferences:', e);
      }
    }
    
    // Load preferences on page load
    loadPreferences();

    // Auto-save preferences
    let orderNumberTimeout;
    orderNumberInput.addEventListener('input', () => {
      clearTimeout(orderNumberTimeout);
      orderNumberTimeout = setTimeout(() => savePreferences(), 500);
    });

    // Enter key support for order number input
    orderNumberInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        loadOrder();
      }
    });

    // STATUS
    function status(text, type = 'info') {
      statusEl.textContent = text;
      statusEl.className = `status text-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'}`;
    }

    // CONSOLE OUTPUT
    function logToConsole(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const prefix = type === 'error' ? '[ERROR]' : type === 'success' ? '[SUCCESS]' : '[INFO]';
      const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
      consoleOutput.innerHTML += `<span class="${className}">[${timestamp}] ${prefix}</span> ${message}\n`;
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    function clearConsole() {
      consoleOutput.textContent = 'Console cleared.\n';
    }

    clearConsoleBtn.addEventListener('click', clearConsole);

    // API
    async function api(action, data = {}, showDetails = false) {
      const headers = { 'Content-Type': 'application/json' };
      if (token) headers.Authorization = `Bearer ${token}`;
      
      // Only show detailed logging for non-auth calls if requested
      if (showDetails && action !== 'auth') {
        logToConsole(`API Call: ${action}`, 'info');
        // Filter out token from request logging
        const logData = { ...data };
        if (logData.token) logData.token = '[REDACTED]';
        logToConsole(`Request: ${JSON.stringify(logData, null, 2)}`, 'info');
      }
      
      try {
        const response = await fetch(`/api/${action}`, {
          method: 'POST',
          headers,
          body: JSON.stringify(data)
        });
        const result = await response.json();
        
        // Only show detailed response for non-auth calls if requested
        if (showDetails && action !== 'auth') {
          // Filter out token from response logging
          const logResult = { ...result };
          if (logResult.token) logResult.token = '[REDACTED]';
          logToConsole(`Response: ${JSON.stringify(logResult, null, 2)}`, result.success ? 'success' : 'error');
        }
        
        return result;
      } catch (e) {
        if (showDetails && action !== 'auth') {
          logToConsole(`Exception: ${e.message}`, 'error');
        }
        return { success: false, error: e.message };
      }
    }

    // Attach authentication handlers - try multiple approaches to ensure it works
    function attachAuthHandlers() {
      console.log('attachAuthHandlers called');
      const authButton = document.getElementById('authBtn');
      const orgInputField = document.getElementById('org');
      
      console.log('authButton:', authButton);
      console.log('orgInputField:', orgInputField);
      
      // Attach event handlers for authentication
      if (authButton) {
        // Remove any existing handlers first
        authButton.onclick = null;
        // Add new handler with explicit logging
        authButton.onclick = function(e) {
          console.log('AUTH BUTTON CLICKED!', e);
          e.preventDefault();
          e.stopPropagation();
          logToConsole('Authentication button clicked!', 'info');
          console.log('Calling authenticate()...');
          authenticate().then(() => {
            console.log('Authentication succeeded');
          }).catch(err => {
            console.error('Authentication error:', err);
            logToConsole(`Authentication error: ${err.message}`, 'error');
          });
        };
        console.log('Authentication button handler attached');
        logToConsole('Authentication button handler attached successfully', 'success');
      } else {
        console.error('ERROR: authBtn element not found!');
        logToConsole('ERROR: authBtn element not found! Check HTML for id="authBtn"', 'error');
      }
      
      // Allow Enter key to trigger authentication
      if (orgInputField) {
        orgInputField.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            console.log('Enter key pressed in org input');
            authenticate().catch(err => {
              console.error('Authentication error:', err);
              logToConsole(`Authentication error: ${err.message}`, 'error');
            });
          }
        });
        console.log('Enter key handler attached to org input');
        logToConsole('Enter key handler attached to org input', 'info');
      } else {
        console.error('ERROR: org input element not found!');
        logToConsole('ERROR: org input element not found!', 'error');
      }
    }
    
    // Try attaching handlers immediately if DOM is already ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', attachAuthHandlers);
    } else {
      // DOM is already ready
      attachAuthHandlers();
    }
    
    // Also try on window load as backup
    window.addEventListener('load', () => {
      console.log('Window load event fired');
      // Re-attach handlers as backup
      attachAuthHandlers();
    });
    
    // Window load for other initialization (separate from auth handlers)
    window.addEventListener('load', async () => {
      // Track app opened
      const urlParams = new URLSearchParams(window.location.search);
      await trackEvent('app_opened', {
        has_url_params: window.location.search.length > 0,
        url_org: urlParams.get('Organization') || null,
        url_order_id: urlParams.get('OrderId') || null
      });
      
      // Initialize JSON editor (non-blocking - won't break if CodeMirror fails)
      try {
        initJsonEditor();
      } catch (e) {
        logToConsole(`JSON editor initialization error (non-critical): ${e.message}`, 'error');
      }
      
      // Date picker button functionality
      const pickupStartCalendarBtn = document.getElementById('pickupStartCalendarBtn');
      if (pickupStartCalendarBtn) {
        pickupStartCalendarBtn.addEventListener('click', () => {
          summaryPickupStart.showPicker ? summaryPickupStart.showPicker() : summaryPickupStart.focus();
        });
      }
      
      // Check for URL parameters for auto-authentication and order loading
      const urlOrg = urlParams.get('Organization');
      const urlOrderId = urlParams.get('OrderId');
      
      if (urlOrg && urlOrg.trim()) {
        // Auto-populate ORG and authenticate
        orgInput.value = urlOrg.trim();
        logToConsole(`ORG detected in URL: ${urlOrg.trim()}. Auto-authenticating...`, 'info');
        
        // Auto-authenticate
        authenticate().then(() => {
          // After authentication, if OrderId is in URL, populate it and auto-load
          if (urlOrderId && urlOrderId.trim()) {
            orderNumberInput.value = urlOrderId.trim();
            logToConsole(`OrderId detected in URL: ${urlOrderId.trim()}. Auto-loading order...`, 'info');
            
            // Auto-load the order
            loadOrder();
          } else {
            orderNumberInput.focus();
          }
        }).catch(error => {
          logToConsole(`Auto-authentication error: ${error.message}`, 'error');
          orgInput.focus();
        });
      } else {
        orgInput.focus();
      }
    });

    // Auth
    async function authenticate() {
      console.log('authenticate() function called');
      logToConsole('=== AUTHENTICATE FUNCTION CALLED ===', 'info');
      
      // Re-query orgInput to ensure it exists
      const orgInputElement = document.getElementById('org') || orgInput;
      if (!orgInputElement) {
        const errorMsg = 'ORG input element not found';
        console.error(errorMsg);
        logToConsole(errorMsg, 'error');
        throw new Error(errorMsg);
      }
      
      const org = orgInputElement.value.trim();
      console.log('ORG value:', org);
      logToConsole(`ORG value: ${org}`, 'info');
      
      // Track auth attempt
      authAttemptCount++;
      const authStartTime = Date.now();
      const urlParams = new URLSearchParams(window.location.search);
      await trackEvent('auth_attempt', {
        org: org || 'unknown',
        url_order_id: urlParams.get('OrderId') || null
      });
      
      if (!org) {
        status('ORG required', 'error');
        if (mainUI) mainUI.style.display = 'none';
        
        // Track auth failure
        const authDuration = Date.now() - authStartTime;
        await trackEvent('auth_failed', {
          error: 'ORG required',
          auth_duration_ms: authDuration,
          token_received: false,
          url_order_id: urlParams.get('OrderId') || null
        });
        
        throw new Error('ORG required');
      }
      
      status('Authenticating...');
      logToConsole('Calling API: auth', 'info');
      console.log('Calling api("auth", { org }, false)');
      
      const res = await api('auth', { org }, false);
      console.log('API response:', res);
      const authDuration = Date.now() - authStartTime;
      
      if (!res.success) {
        // Log detailed error to console
        logToConsole('=== AUTH API ERROR ===', 'error');
        logToConsole(`Error: ${res.error || 'Unknown error'}`, 'error');
        if (res.error && res.error.length > 200) {
          logToConsole(`Full Error Details:`, 'error');
          logToConsole(res.error, 'error');
        }
        
        // Show simple message to user
        status('Authentication failed', 'error');
        logToConsole('Authentication: Failed', 'error');
        mainUI.style.display = 'none';
        
        // Track auth failure
        await trackEvent('auth_failed', {
          org: org,
          error: res.error || 'Authentication failed',
          auth_duration_ms: authDuration,
          token_received: false,
          url_order_id: urlParams.get('OrderId') || null
        });
        
        throw new Error(res.error || 'Authentication failed');
      }
      token = res.token;
      status('Authenticated â€“ ready!', 'success');
      logToConsole('Authentication: Succeeded', 'success');
      mainUI.style.display = 'block';
      
      // Track auth success
      await trackEvent('auth_success', {
        org: org,
        auth_duration_ms: authDuration,
        token_received: !!token,
        url_order_id: urlParams.get('OrderId') || null
      });
      if (firstAuthSuccess) {
        firstAuthSuccess = false;
      }
      
      // Hide ORG section after authentication
      if (orgSection) {
        orgSection.style.display = 'none';
      }
      
      // Load UOMs after authentication (don't let errors crash the app)
      try {
        loadUOMs().catch(err => {
          logToConsole(`Warning: Failed to load UOMs: ${err.message}`, 'error');
        });
      } catch (e) {
        logToConsole(`Warning: Error loading UOMs: ${e.message}`, 'error');
      }
      
      return { success: true, token };
    }
    
    // Load available UOMs
    async function loadUOMs() {
      const org = orgInput.value.trim();
      if (!org || !token) return;

      try {
        const res = await api('search_uoms', { org, token }, false);
        if (res.success && res.data) {
          availableUOMs = res.data;
          logToConsole(`Loaded ${availableUOMs.length} UOMs`, 'success');
        }
      } catch (e) {
        logToConsole(`Error loading UOMs: ${e.message}`, 'error');
      }
    }

    // ===== ORDER NUMBER PARSING =====
    
    // Parse order numbers from input (supports multiple, ranges)
    function parseOrderNumbers(input) {
      const orderNumbers = [];
      const errors = [];
      
      // Split by space, comma, or semicolon
      const parts = input.split(/[\s,;]+/).filter(p => p.trim());
      
      for (const part of parts) {
        const trimmed = part.trim();
        if (!trimmed) continue;
        
        // Check if it's a range (contains dash)
        if (trimmed.includes('-')) {
          const [start, end] = trimmed.split('-').map(s => s.trim());
          
          if (!start || !end) {
            errors.push(`Invalid range format: ${trimmed}`);
            continue;
          }
          
          // Extract base and numbers
          const startMatch = start.match(/^(.+?)(\d+)$/);
          const endMatch = end.match(/^(.+?)(\d+)$/);
          
          if (!startMatch || !endMatch) {
            errors.push(`Invalid range format: ${trimmed}`);
            continue;
          }
          
          const startBase = startMatch[1];
          const startNum = parseInt(startMatch[2]);
          const endBase = endMatch[1];
          const endNum = parseInt(endMatch[2]);
          
          // Validate base matches
          if (startBase !== endBase) {
            errors.push(`Range bases don't match: ${trimmed}`);
            continue;
          }
          
          // Validate numbers
          if (isNaN(startNum) || isNaN(endNum)) {
            errors.push(`Invalid numbers in range: ${trimmed}`);
            continue;
          }
          
          // Validate range direction
          if (endNum < startNum) {
            errors.push(`Invalid range: ${trimmed} (end must be >= start)`);
            continue;
          }
          
          // Validate padding consistency
          const startPadding = startMatch[2].length;
          const endPadding = endMatch[2].length;
          if (startPadding !== endPadding) {
            errors.push(`Invalid range: ${trimmed} (number padding must match)`);
            continue;
          }
          
          // Generate range
          for (let i = startNum; i <= endNum; i++) {
            const numStr = String(i).padStart(startPadding, '0');
            orderNumbers.push(startBase + numStr);
          }
        } else {
          // Single order number
          orderNumbers.push(trimmed);
        }
      }
      
      return { orderNumbers, errors };
    }
    
    // ===== ORDER DATA TRANSFORMATION FUNCTIONS =====
    
    // Recursively remove specified fields from an object
    function cleanOrderData(obj) {
      if (!obj || typeof obj !== 'object') return;
      
      // Handle arrays
      if (Array.isArray(obj)) {
        obj.forEach(item => cleanOrderData(item));
        return;
      }
      
      // Fields to remove
      const fieldsToRemove = [
        'PK', 'pk',
        'Unique_Identifier', 'unique_identifier', 'Unique_Identifier',
        'CreatedBy', 'createdBy',
        'CreatedTimestamp', 'createdTimestamp',
        'UpdatedBy', 'updatedBy',
        'UpdatedTimestamp', 'updatedTimestamp',
        'Process', 'process',
        'ContextId', 'contextId',
        'PurgeDate', 'purgeDate'
      ];
      
      // Remove specified fields
      fieldsToRemove.forEach(field => {
        if (field in obj) {
          delete obj[field];
        }
      });
      
      // Recursively process all properties (including nested objects and arrays)
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const value = obj[key];
          if (value !== null && typeof value === 'object') {
            cleanOrderData(value);
          }
        }
      }
    }
    
    // Sync OrderType and DestinationFacilityId from order header to all order lines
    // Also sync DisplayQuantity and OriginalOrderedQuantity to match OrderedQuantity
    function syncOrderLineFields(orderData) {
      if (!orderData) return;
      
      // Get values from order header
      // Handle OrderType - can be string or object with OrderTypeId
      let orderType = orderData.OrderType || orderData.orderType;
      if (orderType && typeof orderType === 'object') {
        orderType = orderType.OrderTypeId || orderType.orderTypeId || orderType;
      }
      const destinationFacilityId = orderData.DestinationFacilityId || orderData.destinationFacilityId;
      
      // Sync to all order lines
      const orderLines = orderData.OrderLine || orderData.orderLine || [];
      orderLines.forEach(line => {
        if (orderType !== undefined && orderType !== null && orderType !== '') {
          line.OrderType = orderType;
          line.orderType = orderType;
        }
        if (destinationFacilityId !== undefined && destinationFacilityId !== null && destinationFacilityId !== '') {
          line.DestinationFacilityId = destinationFacilityId;
          line.destinationFacilityId = destinationFacilityId;
        }
        
        // Sync DisplayQuantity and OriginalOrderedQuantity to match OrderedQuantity
        const orderedQty = line.OrderedQuantity || line.orderedQuantity || line.Quantity || line.quantity || 0;
        if (orderedQty !== undefined && orderedQty !== null) {
          line.DisplayQuantity = orderedQty;
          line.displayQuantity = orderedQty;
          line.OriginalOrderedQuantity = orderedQty;
          line.originalOrderedQuantity = orderedQty;
        }
      });
    }
    
    // Recursively update all OrderId fields in an object
    function updateAllOrderIds(obj, newOrderId) {
      if (!obj || typeof obj !== 'object') return;
      
      // Handle arrays
      if (Array.isArray(obj)) {
        obj.forEach(item => updateAllOrderIds(item, newOrderId));
        return;
      }
      
      // Update OrderId fields (both camelCase and PascalCase) - check both direct and inherited
      if ('OrderId' in obj) {
        obj.OrderId = newOrderId;
      }
      if ('orderId' in obj) {
        obj.orderId = newOrderId;
      }
      
      // Also check for nested Order objects (e.g., OrderLine.Order.OrderId)
      if (obj.Order && typeof obj.Order === 'object') {
        if ('OrderId' in obj.Order) {
          obj.Order.OrderId = newOrderId;
        }
        if ('orderId' in obj.Order) {
          obj.Order.orderId = newOrderId;
        }
      }
      
      // Recursively process all properties (including nested objects and arrays)
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const value = obj[key];
          if (value !== null && typeof value === 'object') {
            updateAllOrderIds(value, newOrderId);
          }
        }
      }
    }
    
    // Validate that cleaned fields are not present in the payload
    function validateCleanedFields(obj, path = '') {
      const errors = [];
      const fieldsToCheck = [
        'PK', 'pk',
        'Unique_Identifier', 'unique_identifier',
        'CreatedBy', 'createdBy',
        'CreatedTimestamp', 'createdTimestamp',
        'UpdatedBy', 'updatedBy',
        'UpdatedTimestamp', 'updatedTimestamp',
        'Process', 'process',
        'ContextId', 'contextId',
        'PurgeDate', 'purgeDate'
      ];
      
      if (!obj || typeof obj !== 'object') return errors;
      
      // Handle arrays
      if (Array.isArray(obj)) {
        obj.forEach((item, index) => {
          errors.push(...validateCleanedFields(item, `${path}[${index}]`));
        });
        return errors;
      }
      
      // Check for cleaned fields
      fieldsToCheck.forEach(field => {
        if (field in obj) {
          errors.push(`Found cleaned field '${field}' at path: ${path || 'root'}`);
        }
      });
      
      // Recursively check nested objects
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const value = obj[key];
          if (value !== null && typeof value === 'object') {
            const newPath = path ? `${path}.${key}` : key;
            errors.push(...validateCleanedFields(value, newPath));
          }
        }
      }
      
      return errors;
    }
    
    // Calculate PickupEndDateTime as PickupStartDateTime + 1 day
    function calculatePickupEndDateTime(orderData) {
      const pickupStart = orderData.PickupStartDateTime || orderData.pickupStartDateTime;
      if (!pickupStart) return;
      
      try {
        const startDate = new Date(pickupStart);
        if (!isNaN(startDate.getTime())) {
          // Add 1 day
          const endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 1);
          
          // Format as ISO string (YYYY-MM-DDTHH:mm:ss)
          const year = endDate.getFullYear();
          const month = String(endDate.getMonth() + 1).padStart(2, '0');
          const day = String(endDate.getDate()).padStart(2, '0');
          const hours = String(endDate.getHours()).padStart(2, '0');
          const minutes = String(endDate.getMinutes()).padStart(2, '0');
          const seconds = String(endDate.getSeconds()).padStart(2, '0');
          const isoValue = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
          
          orderData.PickupEndDateTime = isoValue;
          orderData.pickupEndDateTime = isoValue;
        }
      } catch (e) {
        logToConsole(`Error calculating PickupEndDateTime: ${e.message}`, 'error');
      }
    }
    
    // ===== VALIDATION FUNCTIONS =====
    
    // Validate order data before sending
    function validateOrderData(orderData) {
      const errors = [];
      
      // Validate summary fields
      if (!orderData.OrderId && !orderData.orderId) {
        errors.push('Order Number is required');
      }
      
      if (!orderData.OrderType && !orderData.orderType) {
        errors.push('Order Type is required');
      }
      
      if (!orderData.DestinationFacilityId && !orderData.destinationFacilityId) {
        errors.push('Destination Facility is required');
      }
      
      if (!orderData.PickupStartDateTime && !orderData.pickupStartDateTime) {
        errors.push('Pickup Start Date/Time is required');
      }
      
      // Validate order lines
      const orderLines = orderData.OrderLine || orderData.orderLine || [];
      if (orderLines.length === 0) {
        errors.push('At least one order line is required');
      }
      
      orderLines.forEach((line, index) => {
        const itemId = line.ItemId || line.itemId || '';
        const quantity = line.OrderedQuantity || line.orderedQuantity || 0;
        
        if (!itemId.trim()) {
          errors.push(`Order Line ${index + 1}: Item ID is required`);
        }
        
        if (!quantity || quantity <= 0) {
          errors.push(`Order Line ${index + 1}: Quantity must be greater than 0`);
        }
      });
      
      return errors;
    }
    
    // Validate items using API
    async function validateItems(itemIds) {
      if (!itemIds || itemIds.length === 0) return { valid: true, invalidItems: [] };
      
      const org = orgInput.value.trim();
      if (!org || !token) return { valid: true, invalidItems: [] };
      
      try {
        const query = `ItemId IN ([${itemIds.map(id => `'${id}'`).join(',')}])`;
        
        // Log detailed API call information
        const facilityId = `${org.toUpperCase()}-DM1`;
        const apiUrl = `https://salep.sce.manh.com/item-master/api/item-master/item/search`;
        const payload = { Query: query };
        
        logToConsole('=== VALIDATE ITEMS API CALL ===', 'info');
        logToConsole(`Method: POST`, 'info');
        logToConsole(`URL: ${apiUrl}`, 'info');
        logToConsole(`Headers:`, 'info');
        logToConsole(`  Authorization: Bearer [REDACTED]`, 'info');
        logToConsole(`  Content-Type: application/json`, 'info');
        logToConsole(`  FacilityId: ${facilityId}`, 'info');
        logToConsole(`  selectedOrganization: ${org.toUpperCase()}`, 'info');
        logToConsole(`  selectedLocation: ${facilityId}`, 'info');
        logToConsole(`Items to validate: ${itemIds.join(', ')}`, 'info');
        logToConsole(`Raw JSON Payload (sent to backend):`, 'info');
        logToConsole(JSON.stringify({ org, token: '[REDACTED]', query }, null, 2), 'info');
        logToConsole(`Raw JSON Payload (sent to Manhattan API):`, 'info');
        logToConsole(JSON.stringify(payload, null, 2), 'info');
        
        const res = await api('validate_items', { org, token, query: query }, false);
        
        // Log response details
        logToConsole('=== VALIDATE ITEMS API RESPONSE ===', 'info');
        if (res.success) {
          logToConsole(`Status: Success`, 'success');
          const responseData = res.data || res.Data || [];
          logToConsole(`Items found: ${responseData.length}`, 'info');
          if (responseData.length > 0) {
            logToConsole(`Valid Item IDs:`, 'info');
            responseData.forEach((item, idx) => {
              const id = item.ItemId || item.itemId || 'N/A';
              const desc = item.Description || item.description || 'N/A';
              logToConsole(`  ${idx + 1}. ItemId: ${id}, Description: ${desc}`, 'info');
            });
          }
        } else {
          logToConsole(`Status: Failed`, 'error');
          logToConsole(`Error: ${res.error || 'Unknown error'}`, 'error');
        }
        
        if (!res.success) {
          return { valid: false, invalidItems: itemIds, error: res.error };
        }
        
        // Extract valid item IDs from response
        const validItemIds = new Set();
        const responseData = res.data || res.Data || [];
        
        if (Array.isArray(responseData)) {
          responseData.forEach(item => {
            const id = item.ItemId || item.itemId;
            if (id) validItemIds.add(id);
          });
        }
        
        const invalidItems = itemIds.filter(id => !validItemIds.has(id));
        
        if (invalidItems.length > 0) {
          logToConsole(`Invalid Item IDs (not found in response): ${invalidItems.join(', ')}`, 'error');
        } else {
          logToConsole(`All items validated successfully!`, 'success');
        }
        
        return { valid: invalidItems.length === 0, invalidItems };
      } catch (e) {
        logToConsole(`=== VALIDATE ITEMS API EXCEPTION ===`, 'error');
        logToConsole(`Exception: ${e.message}`, 'error');
        logToConsole(`Stack: ${e.stack || 'N/A'}`, 'error');
        return { valid: false, invalidItems: itemIds, error: e.message };
      }
    }
    
    // Load Order
    async function loadOrder() {
      if (!token) {
        status('Authenticate first', 'error');
        logToConsole('Authentication required. Please authenticate first.', 'error');
        return;
      }
      
      const orderNumber = orderNumberInput.value.trim();
      if (!orderNumber) {
        loadOrderStatus.textContent = 'Order number required';
        loadOrderStatus.className = 'text-danger';
        logToConsole('Order number is required', 'error');
        return;
      }

      const org = orgInput.value.trim();
      if (!org) {
        status('ORG required', 'error');
        return;
      }

      // Track find order attempt
      const findStartTime = Date.now();
      await trackEvent('find_order_attempt', {
        org: org,
        order_number: orderNumber
      });

      loadOrderStatus.textContent = 'Loading...';
      loadOrderStatus.className = 'text-info';
      createOrderStatus.textContent = ''; // Clear create order status
      loadOrderBtn.disabled = true;

      // Log API call details to console
      const facilityId = `${org.toUpperCase()}-DM1`;
      const apiUrl = `https://salep.sce.manh.com/dcorder/api/dcorder/order/orderId/${orderNumber}`;
      logToConsole('=== LOAD ORDER API CALL ===', 'info');
      logToConsole(`Method: GET`, 'info');
      logToConsole(`URL: ${apiUrl}`, 'info');
      logToConsole(`Path Parameter:`, 'info');
      logToConsole(`  orderId: ${orderNumber}`, 'info');
      logToConsole(`Headers:`, 'info');
      logToConsole(`  Authorization: Bearer [REDACTED]`, 'info');
      logToConsole(`  Content-Type: application/json`, 'info');
      logToConsole(`  FacilityId: ${facilityId}`, 'info');
      logToConsole(`  selectedOrganization: ${org.toUpperCase()}`, 'info');
      logToConsole(`  selectedLocation: ${facilityId}`, 'info');

      try {
        const res = await api('find_order', { org, token, orderNumber }, false);
        
        // Log response details to console
        logToConsole('=== LOAD ORDER API RESPONSE ===', 'info');
        if (res.success && res.orderData) {
          logToConsole(`Status: Success`, 'success');
          logToConsole(`Order loaded: ${res.orderData.OrderId || res.orderData.orderId || orderNumber}`, 'success');
          logToConsole(`Response JSON:`, 'info');
          logToConsole(JSON.stringify(res.orderData, null, 2), 'info');
        } else {
          logToConsole(`Status: Failed`, 'error');
          logToConsole(`Error: ${res.error || 'No order data returned'}`, 'error');
          if (res.error) {
            logToConsole(`Full Error Response:`, 'error');
            logToConsole(res.error, 'error');
          }
        }
        
        if (!res.success) {
          // Log detailed error to console
          logToConsole('=== LOAD ORDER API ERROR ===', 'error');
          logToConsole(`Error: ${res.error || 'Unknown error'}`, 'error');
          if (res.error && res.error.length > 200) {
            // Log full error details to console
            logToConsole(`Full Error Details:`, 'error');
            logToConsole(res.error, 'error');
          }
          
          // Track find order failure
          const findDuration = Date.now() - findStartTime;
          await trackEvent('find_order_failed', {
            org: org,
            order_number: orderNumber,
            error: res.error || 'Order not found',
            find_duration_ms: findDuration
          });
          
          // Show simple message next to button
          loadOrderStatus.textContent = 'Invalid Order';
          loadOrderStatus.className = 'text-danger';
          if (jsonEditor) {
            jsonEditor.setValue('');
          }
          currentOrderData = null;
          summarySection.style.display = 'none';
          orderLinesSection.style.display = 'none';
          createOrderButtonSection.style.display = 'none';
          return;
        }

        if (!res.orderData) {
          // Log detailed error to console
          logToConsole('=== LOAD ORDER API ERROR ===', 'error');
          logToConsole('No order data returned from API', 'error');
          
          // Show simple message next to button
          loadOrderStatus.textContent = 'Invalid Order';
          loadOrderStatus.className = 'text-danger';
          if (jsonEditor) {
            jsonEditor.setValue('');
          }
          currentOrderData = null;
          summarySection.style.display = 'none';
          orderLinesSection.style.display = 'none';
          createOrderButtonSection.style.display = 'none';
          return;
        }

        // Store order data
        currentOrderData = JSON.parse(JSON.stringify(res.orderData)); // Deep copy
        
        // Clean order data (remove PK, Unique_Identifier, timestamps, etc.) for display
        cleanOrderData(currentOrderData);
        
        // Display cleaned order JSON in editor
        const jsonStr = JSON.stringify(currentOrderData, null, 2);
        if (jsonEditor) {
          jsonEditor.setValue(jsonStr);
        }
        
        // Populate summary fields and order lines
        populateSummaryFields(res.orderData);
        populateOrderLines(res.orderData);
        
        // Show summary, order lines, and create order button sections
        summarySection.style.display = 'block';
        orderLinesSection.style.display = 'block';
        createOrderButtonSection.style.display = 'block';
        
        
        // Show success message next to button
        loadOrderStatus.textContent = 'Order loaded successfully!';
        loadOrderStatus.className = 'text-success';
        
        // Track find order success
        const findDuration = Date.now() - findStartTime;
        const orderLines = res.orderData?.OrderLine || res.orderData?.orderLine || [];
        await trackEvent('find_order_completed', {
          org: org,
          order_number: orderNumber,
          order_id: res.orderData?.OrderId || res.orderData?.orderId || orderNumber,
          order_lines_count: orderLines.length,
          order_type: res.orderData?.OrderType?.OrderTypeId || res.orderData?.OrderType || res.orderData?.orderType || null,
          destination_facility: res.orderData?.DestinationFacilityId || res.orderData?.destinationFacilityId || null,
          pickup_start_datetime: res.orderData?.PickupStartDateTime || res.orderData?.pickupStartDateTime || null,
          has_order_data: !!res.orderData,
          find_duration_ms: findDuration
        });
      } catch (e) {
        loadOrderStatus.textContent = `Error: ${e.message}`;
        loadOrderStatus.className = 'text-danger';
        logToConsole(`Exception: ${e.message}`, 'error');
        logToConsole(`Stack: ${e.stack || 'N/A'}`, 'error');
        
        // Track find order failure
        const findDuration = Date.now() - findStartTime;
        await trackEvent('find_order_failed', {
          org: org,
          order_number: orderNumber,
          error: e.message || 'Exception occurred',
          find_duration_ms: findDuration
        });
      } finally {
        loadOrderBtn.disabled = false;
      }
    }

    loadOrderBtn.onclick = loadOrder;

    // Create Order
    async function createOrder() {
      if (!token) {
        status('Authenticate first', 'error');
        logToConsole('Authentication required. Please authenticate first.', 'error');
        return;
      }

      let orderJson;
      try {
        // Use currentOrderData if available, otherwise parse from editor
        if (currentOrderData) {
          orderJson = JSON.parse(JSON.stringify(currentOrderData)); // Deep copy
        } else {
          const jsonStr = jsonEditor ? jsonEditor.getValue() : jsonTextarea.value.trim();
          if (!jsonStr) {
            createOrderStatus.textContent = 'No order data. Load an order first.';
            createOrderStatus.className = 'text-danger';
            logToConsole('No order JSON to create. Load an order first.', 'error');
            return;
          }
          orderJson = JSON.parse(jsonStr);
        }
      } catch (e) {
        createOrderStatus.textContent = 'Invalid JSON format';
        createOrderStatus.className = 'text-danger';
        logToConsole(`Invalid JSON: ${e.message}`, 'error');
        return;
      }

      const org = orgInput.value.trim();
      if (!org) {
        status('ORG required', 'error');
        return;
      }

      // Convert datetime-local to ISO format if needed
      if (orderJson.PickupStartDateTime && orderJson.PickupStartDateTime.length === 16) {
        // datetime-local format, add seconds
        orderJson.PickupStartDateTime = orderJson.PickupStartDateTime + ':00';
      }
      if (orderJson.pickupStartDateTime && orderJson.pickupStartDateTime.length === 16) {
        orderJson.pickupStartDateTime = orderJson.pickupStartDateTime + ':00';
      }

      // Validate order data
      const validationErrors = validateOrderData(orderJson);
      if (validationErrors.length > 0) {
        createOrderStatus.textContent = `Validation failed: ${validationErrors.join('; ')}`;
        createOrderStatus.className = 'text-danger';
        validationErrors.forEach(err => logToConsole(err, 'error'));
        return;
      }

      // Collect item IDs for validation
      const orderLines = orderJson.OrderLine || orderJson.orderLine || [];
      const itemIds = orderLines
        .map(line => line.ItemId || line.itemId)
        .filter(id => id && id.trim());

      // Validate items
      if (itemIds.length > 0) {
        createOrderStatus.textContent = 'Validating items...';
        createOrderStatus.className = 'text-info';
        const itemValidation = await validateItems(itemIds);
        
        if (!itemValidation.valid) {
          if (itemValidation.invalidItems && itemValidation.invalidItems.length > 0) {
            createOrderStatus.textContent = `Invalid items: ${itemValidation.invalidItems.join(', ')}`;
            createOrderStatus.className = 'text-danger';
            logToConsole(`Invalid items found: ${itemValidation.invalidItems.join(', ')}`, 'error');
          } else {
            createOrderStatus.textContent = `Item validation failed: ${itemValidation.error || 'Unknown error'}`;
            createOrderStatus.className = 'text-danger';
            logToConsole(`Item validation error: ${itemValidation.error || 'Unknown error'}`, 'error');
          }
          return;
        }
        logToConsole(`All items validated successfully: ${itemIds.join(', ')}`, 'success');
      }

      createOrderStatus.textContent = 'Creating order...';
      createOrderStatus.className = 'text-info';
      loadOrderStatus.textContent = ''; // Clear load order status
      createOrderBtn.disabled = true;

      // Track create order attempt
      const createStartTime = Date.now();
      const useBulk = parsedOrderNumbers.length > 1;
      
      await trackEvent('create_order_attempt', {
        org: org,
        order_lines_count: orderLines.length,
        item_ids_count: itemIds.length,
        order_type: orderJson.OrderType?.OrderTypeId || orderJson.OrderType || orderJson.orderType || null,
        destination_facility: orderJson.DestinationFacilityId || orderJson.destinationFacilityId || null,
        pickup_start_datetime: orderJson.PickupStartDateTime || orderJson.pickupStartDateTime || null,
        use_bulk: useBulk,
        orders_count: parsedOrderNumbers.length
      });

      // Parse order numbers from summary field for bulk import
      const orderInput = summaryOrderNumber.value.trim();
      const { orderNumbers, errors: parseErrors } = parseOrderNumbers(orderInput);
      
      if (parseErrors.length > 0) {
        createOrderStatus.textContent = `Parse errors: ${parseErrors.join('; ')}`;
        createOrderStatus.className = 'text-danger';
        parseErrors.forEach(err => logToConsole(err, 'error'));
        createOrderBtn.disabled = false;
        return;
      }
      
      // Clear parse errors if valid
      if (orderInput && orderNumbers.length > 0) {
        createOrderStatus.textContent = '';
      }
      
      // Store parsed order numbers
      parsedOrderNumbers = orderNumbers.length > 0 ? orderNumbers : [orderJson.OrderId || orderJson.orderId || ''];
      
      // Clean order data (remove PK, Unique_Identifier, timestamps, etc.)
      cleanOrderData(orderJson);
      logToConsole('Cleaned order data (removed PK, Unique_Identifier, timestamps, etc.)', 'info');
      
      // Sync OrderType and DestinationFacilityId from header to order lines
      syncOrderLineFields(orderJson);
      logToConsole('Synced OrderType and DestinationFacilityId from header to order lines', 'info');
      
      // Validate that cleaned fields are not present
      const cleanedFieldsErrors = validateCleanedFields(orderJson);
      if (cleanedFieldsErrors.length > 0) {
        logToConsole('WARNING: Found cleaned fields in payload:', 'error');
        cleanedFieldsErrors.forEach(err => logToConsole(`  ${err}`, 'error'));
      } else {
        logToConsole('Validation passed: No cleaned fields found in payload', 'success');
      }
      
      // Save original orderJson before any updates (needed for bulk import)
      const originalOrderJson = JSON.parse(JSON.stringify(orderJson));
      
      // Validate that orders don't already exist
      createOrderStatus.textContent = 'Validating orders...';
      createOrderStatus.className = 'text-info';
      
      const existingOrders = [];
      for (const orderNum of parsedOrderNumbers) {
        logToConsole(`Checking if order exists: ${orderNum}`, 'info');
        const checkRes = await api('find_order', { org, token, orderNumber: orderNum }, false);
        if (checkRes.success && checkRes.orderData) {
          existingOrders.push(orderNum);
          logToConsole(`Order ${orderNum} already exists`, 'error');
        }
      }
      
      if (existingOrders.length > 0) {
        const errorMsg = `Orders already exist: ${existingOrders.join(', ')}`;
        createOrderStatus.textContent = errorMsg;
        createOrderStatus.className = 'text-danger';
        logToConsole(`Validation failed: ${errorMsg}`, 'error');
        createOrderBtn.disabled = false;
        return;
      }
      
      logToConsole(`All orders validated - none exist in system`, 'success');
      
      // Use bulk import API if multiple orders, otherwise single order API
      if (useBulk) {
        // Generate multiple orders from template (use original, not updated orderJson)
        const ordersData = parsedOrderNumbers.map((orderNum, index) => {
          const orderCopy = JSON.parse(JSON.stringify(originalOrderJson));
          
          // Clean order data for this copy
          cleanOrderData(orderCopy);
          
          // Sync OrderType and DestinationFacilityId from header to order lines
          syncOrderLineFields(orderCopy);
          
          // Update all OrderId fields recursively with the correct order number for this copy
          updateAllOrderIds(orderCopy, orderNum);
          
          // Verify OrderId updates in OrderLines (explicit check after recursive update)
          if (orderCopy.OrderLine && Array.isArray(orderCopy.OrderLine)) {
            orderCopy.OrderLine.forEach((line, lineIndex) => {
              // Ensure all OrderId fields are updated
              line.OrderId = orderNum;
              line.orderId = orderNum;
              if (line.Order) {
                line.Order.OrderId = orderNum;
                line.Order.orderId = orderNum;
              }
            });
          }
          if (orderCopy.orderLine && Array.isArray(orderCopy.orderLine)) {
            orderCopy.orderLine.forEach((line, lineIndex) => {
              // Ensure all OrderId fields are updated
              line.OrderId = orderNum;
              line.orderId = orderNum;
              if (line.Order) {
                line.Order.OrderId = orderNum;
                line.Order.orderId = orderNum;
              }
            });
          }
          
          // Validate cleaned fields are not present
          const cleanedFieldsErrors = validateCleanedFields(orderCopy);
          if (cleanedFieldsErrors.length > 0) {
            logToConsole(`WARNING: Found cleaned fields in order ${orderNum}:`, 'error');
            cleanedFieldsErrors.forEach(err => logToConsole(`  ${err}`, 'error'));
          }
          
          logToConsole(`Updated all OrderId fields to: ${orderNum} for order ${index + 1}`, 'info');
          // Calculate PickupEndDateTime for each order
          calculatePickupEndDateTime(orderCopy);
          return orderCopy;
        });

        // Use bulk import API for multiple orders
        const apiUrl = `https://salep.sce.manh.com/dcorder/api/dcorder/order/bulkImport?stopOnFirstError=false`;
        logToConsole('=== BULK IMPORT ORDERS API CALL ===', 'info');
        logToConsole(`Method: POST`, 'info');
        logToConsole(`URL: ${apiUrl}`, 'info');
        logToConsole(`Headers:`, 'info');
        logToConsole(`  Authorization: Bearer [REDACTED]`, 'info');
        logToConsole(`  Content-Type: application/json`, 'info');
        logToConsole(`  FacilityId: ${org.toUpperCase()}-DM1`, 'info');
        logToConsole(`  selectedOrganization: ${org.toUpperCase()}`, 'info');
        logToConsole(`  selectedLocation: ${org.toUpperCase()}-DM1`, 'info');
        logToConsole(`Payload (${ordersData.length} orders):`, 'info');
        logToConsole(JSON.stringify({ Data: ordersData }, null, 2), 'info');

        try {
          const bulkStartTime = Date.now();
          const res = await api('bulk_import_orders', { org, token, ordersData }, true);
          const bulkDuration = Date.now() - bulkStartTime;
          
          // Log response details to console
          logToConsole('=== BULK IMPORT ORDERS API RESPONSE ===', 'info');
          if (res.success) {
            logToConsole(`Status: Success`, 'success');
            logToConsole(`Response:`, 'info');
            logToConsole(JSON.stringify(res.response || res, null, 2), 'info');
          } else {
            logToConsole(`Status: Failed`, 'error');
            logToConsole(`Error: ${res.error || 'Unknown error'}`, 'error');
            if (res.error) {
              logToConsole(`Full Error Response:`, 'error');
              logToConsole(res.error, 'error');
            }
          }
          
          // Check the actual response data for SuccessCount and TotalCount
          const responseData = res.response?.data || res.response?.Data || res.data || res.response || {};
          const successCount = responseData.SuccessCount ?? responseData.successCount ?? responseData.Success ?? 0;
          const totalCount = responseData.TotalCount ?? responseData.totalCount ?? responseData.Total ?? ordersData.length;
          const failedCount = responseData.FailedCount ?? responseData.failedCount ?? responseData.Failed ?? 0;
          
          logToConsole(`Bulk import results: SuccessCount=${successCount}, TotalCount=${totalCount}, FailedCount=${failedCount}`, 'info');
          
          if (!res.success || (successCount === 0 && totalCount > 0)) {
            // Track bulk import failure
            await trackEvent('bulk_import_orders_failed', {
              org: org,
              orders_count: ordersData.length,
              success_count: successCount,
              failed_count: failedCount,
              total_count: totalCount,
              error: res.error || 'Bulk import failed',
              bulk_import_duration_ms: bulkDuration
            });
            
            // Show simple message next to button
            if (successCount === 0 && totalCount > 0) {
              createOrderStatus.textContent = `Bulk import failed: 0 of ${totalCount} orders imported`;
              createOrderStatus.className = 'text-danger';
              logToConsole(`Bulk import failed: 0 of ${totalCount} orders imported`, 'error');
            } else {
              createOrderStatus.textContent = 'Bulk import failed';
              createOrderStatus.className = 'text-danger';
            }
            createOrderBtn.disabled = false;
            return;
          }

          // Determine if import was actually successful based on SuccessCount
          const partialSuccess = successCount > 0 && successCount < totalCount;
          
          if (partialSuccess) {
            // Partial success
            createOrderStatus.textContent = `Partially successful: ${successCount} of ${totalCount} orders imported`;
            createOrderStatus.className = 'text-warning';
            logToConsole(`Bulk import partially successful: ${successCount} of ${totalCount} orders imported`, 'warning');
          } else if (successCount === totalCount && totalCount > 0) {
            // Complete success
            createOrderStatus.textContent = `Successfully imported ${successCount} of ${totalCount} orders!`;
            createOrderStatus.className = 'text-success';
            logToConsole(`Bulk import successful: ${successCount} of ${totalCount} orders imported`, 'success');
          } else {
            // Fallback - use res.success but log warning
            createOrderStatus.textContent = `Bulk import completed (${successCount}/${totalCount} successful)`;
            createOrderStatus.className = successCount > 0 ? 'text-success' : 'text-danger';
            logToConsole(`Bulk import completed: ${successCount} of ${totalCount} orders imported`, successCount > 0 ? 'success' : 'error');
          }
          
          // Track bulk import success
          await trackEvent('bulk_import_orders_completed', {
            org: org,
            orders_count: ordersData.length,
            success_count: successCount,
            failed_count: failedCount,
            total_count: totalCount,
            partial_success: partialSuccess,
            bulk_import_duration_ms: bulkDuration
          });
          
          createOrderBtn.disabled = false;
        } catch (e) {
          const bulkDuration = Date.now() - createStartTime;
          await trackEvent('bulk_import_orders_failed', {
            org: org,
            orders_count: ordersData.length,
            error: e.message || 'Exception occurred',
            bulk_import_duration_ms: bulkDuration
          });
          
          createOrderStatus.textContent = `Error: ${e.message}`;
          createOrderStatus.className = 'text-danger';
          logToConsole(`Exception: ${e.message}`, 'error');
          logToConsole(`Stack: ${e.stack || 'N/A'}`, 'error');
          createOrderBtn.disabled = false;
        }
      } else {
        // Single order - clean data, sync fields, update OrderId and PickupEndDateTime
        // Clean order data (already done above, but ensure it's clean)
        cleanOrderData(orderJson);
        syncOrderLineFields(orderJson);
        
        if (parsedOrderNumbers.length > 0) {
          const orderId = parsedOrderNumbers[0];
          updateAllOrderIds(orderJson, orderId);
          
          // Verify OrderId updates in OrderLines (explicit check after recursive update)
          if (orderJson.OrderLine && Array.isArray(orderJson.OrderLine)) {
            orderJson.OrderLine.forEach((line) => {
              // Ensure all OrderId fields are updated
              line.OrderId = orderId;
              line.orderId = orderId;
              if (line.Order) {
                line.Order.OrderId = orderId;
                line.Order.orderId = orderId;
              }
            });
          }
          if (orderJson.orderLine && Array.isArray(orderJson.orderLine)) {
            orderJson.orderLine.forEach((line) => {
              // Ensure all OrderId fields are updated
              line.OrderId = orderId;
              line.orderId = orderId;
              if (line.Order) {
                line.Order.OrderId = orderId;
                line.Order.orderId = orderId;
              }
            });
          }
          
          // Validate cleaned fields are not present
          const cleanedFieldsErrors = validateCleanedFields(orderJson);
          if (cleanedFieldsErrors.length > 0) {
            logToConsole('WARNING: Found cleaned fields in payload:', 'error');
            cleanedFieldsErrors.forEach(err => logToConsole(`  ${err}`, 'error'));
          } else {
            logToConsole('Validation passed: No cleaned fields found in payload', 'success');
          }
          
          logToConsole(`Updated all OrderId fields to: ${orderId}`, 'info');
        }
        calculatePickupEndDateTime(orderJson);
        logToConsole(`Calculated PickupEndDateTime as PickupStartDateTime + 1 day`, 'info');
        
        // Single order
        const facilityId = `${org.toUpperCase()}-DM1`;
        const apiUrl = `https://salep.sce.manh.com/dcorder/api/dcorder/order`;
        logToConsole('=== CREATE ORDER API CALL ===', 'info');
        logToConsole(`Method: POST`, 'info');
        logToConsole(`URL: ${apiUrl}`, 'info');
        logToConsole(`Headers:`, 'info');
        logToConsole(`  Authorization: Bearer [REDACTED]`, 'info');
        logToConsole(`  Content-Type: application/json`, 'info');
        logToConsole(`  FacilityId: ${facilityId}`, 'info');
        logToConsole(`  selectedOrganization: ${org.toUpperCase()}`, 'info');
        logToConsole(`  selectedLocation: ${facilityId}`, 'info');
        logToConsole(`Payload:`, 'info');
        logToConsole(JSON.stringify(orderJson, null, 2), 'info');

        try {
          const res = await api('create_order', { org, token, orderData: orderJson }, true);
          
          // Log response details to console
          logToConsole('=== CREATE ORDER API RESPONSE ===', 'info');
          if (res.success) {
            logToConsole(`Status: Success`, 'success');
            if (res.orderId) {
              logToConsole(`New Order ID: ${res.orderId}`, 'success');
            }
            logToConsole(`Response:`, 'info');
            logToConsole(JSON.stringify(res.response || res, null, 2), 'info');
          } else {
            logToConsole(`Status: Failed`, 'error');
            logToConsole(`Error: ${res.error || 'Unknown error'}`, 'error');
            if (res.error) {
              logToConsole(`Full Error Response:`, 'error');
              logToConsole(res.error, 'error');
            }
          }
          
          if (!res.success) {
            // Track create order failure
            const createDuration = Date.now() - createStartTime;
            await trackEvent('create_order_failed', {
              org: org,
              error: res.error || 'Create failed',
              create_duration_ms: createDuration,
              use_bulk: useBulk,
              orders_count: parsedOrderNumbers.length
            });
            
            // Show simple message next to button
            createOrderStatus.textContent = 'Create failed';
            createOrderStatus.className = 'text-danger';
            return;
          }

          // Show success message next to button
          createOrderStatus.textContent = 'Order created successfully!';
          createOrderStatus.className = 'text-success';
          if (res.orderId) {
            logToConsole(`New Order ID: ${res.orderId}`, 'success');
          }
          
          // Track create order success
          const createDuration = Date.now() - createStartTime;
          await trackEvent('create_order_completed', {
            org: org,
            order_id: res.orderId || 'unknown',
            source_order_id: currentOrderData?.OrderId || currentOrderData?.orderId || null,
            order_lines_count: orderLines.length,
            item_ids_count: itemIds.length,
            order_type: orderJson.OrderType?.OrderTypeId || orderJson.OrderType || orderJson.orderType || null,
            destination_facility: orderJson.DestinationFacilityId || orderJson.destinationFacilityId || null,
            pickup_start_datetime: orderJson.PickupStartDateTime || orderJson.pickupStartDateTime || null,
            use_bulk: useBulk,
            orders_count: parsedOrderNumbers.length,
            create_duration_ms: createDuration
          });
        } catch (e) {
          createOrderStatus.textContent = `Error: ${e.message}`;
          createOrderStatus.className = 'text-danger';
          logToConsole(`Exception: ${e.message}`, 'error');
          logToConsole(`Stack: ${e.stack || 'N/A'}`, 'error');
        } finally {
          createOrderBtn.disabled = false;
        }
      }
    }

    createOrderBtn.onclick = createOrder;

    // ===== SUMMARY FIELDS AND ORDER LINES FUNCTIONS =====
    
    // Populate summary fields from order data
    function populateSummaryFields(orderData) {
      // Order Number
      summaryOrderNumber.value = orderData.OrderId || orderData.orderId || '';
      
      // Order Type (could be OrderType.OrderTypeId or OrderType string)
      const orderType = orderData.OrderType;
      if (orderType) {
        summaryOrderType.value = typeof orderType === 'string' ? orderType : (orderType.OrderTypeId || orderType.orderTypeId || '');
      } else {
        summaryOrderType.value = '';
      }
      
      // Destination Facility
      summaryDestinationFacility.value = orderData.DestinationFacilityId || orderData.destinationFacilityId || '';
      
      // Pickup Start Date/Time - convert to datetime-local format
      const pickupStart = orderData.PickupStartDateTime || orderData.pickupStartDateTime || 
                         orderData.PickupStartDate || orderData.pickupStartDate || '';
      if (pickupStart) {
        // Convert ISO format to datetime-local format (YYYY-MM-DDTHH:mm)
        const date = new Date(pickupStart);
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          summaryPickupStart.value = `${year}-${month}-${day}T${hours}:${minutes}`;
        } else {
          summaryPickupStart.value = pickupStart;
        }
      } else {
        summaryPickupStart.value = '';
      }
    }
    
    // Populate order lines accordion
    function populateOrderLines(orderData) {
      const orderLines = orderData.OrderLine || orderData.orderLine || [];
      orderLinesAccordion.innerHTML = '';
      
      if (orderLines.length === 0) {
        orderLinesAccordion.innerHTML = '<div class="text-muted p-3">No order lines found</div>';
        return;
      }
      
      // Sync DisplayQuantity and OriginalOrderedQuantity to match OrderedQuantity for all lines
      orderLines.forEach(line => {
        const orderedQty = line.OrderedQuantity || line.orderedQuantity || line.Quantity || line.quantity || 0;
        if (orderedQty !== undefined && orderedQty !== null) {
          line.DisplayQuantity = orderedQty;
          line.displayQuantity = orderedQty;
          line.OriginalOrderedQuantity = orderedQty;
          line.originalOrderedQuantity = orderedQty;
        }
      });
      
      orderLines.forEach((line, index) => {
        const lineId = `line${index}`;
        const itemId = line.ItemId || line.itemId || '';
        const quantity = line.OrderedQuantity || line.orderedQuantity || line.Quantity || line.quantity || '';
        const uom = line.QuantityUomId || line.quantityUomId || line.UOM || line.uom || '';
        
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        accordionItem.innerHTML = `
          <h2 class="accordion-header">
            <button class="accordion-button ${index === 0 ? '' : 'collapsed'}" type="button" data-bs-toggle="collapse" data-bs-target="#${lineId}">
              Order Line ${index + 1} - ${itemId || 'No Item'} (Qty: ${quantity}, UOM: ${uom})
            </button>
          </h2>
          <div id="${lineId}" class="accordion-collapse collapse ${index === 0 ? 'show' : ''}" data-bs-parent="#orderLinesAccordion">
            <div class="accordion-body">
              <div class="row g-3">
                <div class="col-md-4">
                  <label class="form-label">Item ID</label>
                  <input type="text" class="form-control order-line-item" data-line-index="${index}" data-field="ItemId" value="${itemId}" />
                </div>
                <div class="col-md-4">
                  <label class="form-label">Quantity</label>
                  <input type="number" class="form-control order-line-qty" data-line-index="${index}" data-field="OrderedQuantity" value="${quantity}" />
                </div>
                <div class="col-md-4">
                  <label class="form-label">UOM</label>
                  <select class="form-select order-line-uom" data-line-index="${index}" data-field="QuantityUomId">
                    <option value="">Select UOM...</option>
                    ${availableUOMs.map(uomOption => {
                      const uomId = uomOption.UnitOfMeasureId || uomOption.unitOfMeasureId || '';
                      const description = uomOption.Description || uomOption.description || uomId;
                      const selected = uomId === uom ? 'selected' : '';
                      return `<option value="${uomId}" ${selected}>${description}</option>`;
                    }).join('')}
                  </select>
                </div>
              </div>
              <div class="mt-2 d-flex gap-2">
                <button type="button" class="btn btn-sm btn-success add-line-after-btn" data-line-index="${index}">+ Add Line</button>
                <button type="button" class="btn btn-sm btn-danger remove-line-btn" data-line-index="${index}" ${orderLines.length === 1 ? 'style="display: none;"' : ''}>- Remove Line</button>
              </div>
            </div>
          </div>
        `;
        orderLinesAccordion.appendChild(accordionItem);
      });
      
      // Add event listeners for order line changes
      attachOrderLineListeners();
    }
    
    // Attach event listeners to order line inputs
    function attachOrderLineListeners() {
      // Remove old listeners by cloning
      const inputs = orderLinesAccordion.querySelectorAll('.order-line-item, .order-line-qty');
      inputs.forEach(input => {
        input.addEventListener('input', syncOrderLineToJSON);
      });
      
      // UOM dropdowns
      const uomSelects = orderLinesAccordion.querySelectorAll('.order-line-uom');
      uomSelects.forEach(select => {
        select.addEventListener('change', syncOrderLineToJSON);
      });
      
      // Remove line buttons
      const removeBtns = orderLinesAccordion.querySelectorAll('.remove-line-btn');
      removeBtns.forEach(btn => {
        btn.addEventListener('click', removeOrderLine);
      });
      
      // Add line after buttons
      const addAfterBtns = orderLinesAccordion.querySelectorAll('.add-line-after-btn');
      addAfterBtns.forEach(btn => {
        btn.addEventListener('click', addOrderLineAfter);
      });
    }
    
    // Sync order line changes to JSON
    function syncOrderLineToJSON(e) {
      if (!currentOrderData) return;
      
      const lineIndex = parseInt(e.target.dataset.lineIndex);
      const field = e.target.dataset.field;
      const value = e.target.value;
      
      const orderLines = currentOrderData.OrderLine || currentOrderData.orderLine || [];
      if (orderLines[lineIndex]) {
        // Update the field (handle both camelCase and PascalCase)
        orderLines[lineIndex][field] = value;
        if (field === 'ItemId') {
          orderLines[lineIndex].itemId = value;
        } else if (field === 'OrderedQuantity') {
          const qtyValue = parseFloat(value) || 0;
          orderLines[lineIndex].OrderedQuantity = qtyValue;
          orderLines[lineIndex].orderedQuantity = qtyValue;
          // Also update Quantity for backwards compatibility
          orderLines[lineIndex].Quantity = qtyValue;
          orderLines[lineIndex].quantity = qtyValue;
          // Sync DisplayQuantity and OriginalOrderedQuantity to match OrderedQuantity
          orderLines[lineIndex].DisplayQuantity = qtyValue;
          orderLines[lineIndex].displayQuantity = qtyValue;
          orderLines[lineIndex].OriginalOrderedQuantity = qtyValue;
          orderLines[lineIndex].originalOrderedQuantity = qtyValue;
        } else if (field === 'QuantityUomId') {
          orderLines[lineIndex].quantityUomId = value;
          orderLines[lineIndex].UOM = value;
          orderLines[lineIndex].uom = value;
        }
        
        // Update JSON editor
        updateJSONFromCurrentData();
        
        // Update accordion header
        updateAccordionHeader(lineIndex);
      }
    }
    
    // Update accordion header text
    function updateAccordionHeader(lineIndex) {
      const accordionItem = orderLinesAccordion.children[lineIndex];
      if (!accordionItem) return;
      
      const button = accordionItem.querySelector('.accordion-button');
      const itemInput = accordionItem.querySelector('.order-line-item');
      const qtyInput = accordionItem.querySelector('.order-line-qty');
      const uomSelect = accordionItem.querySelector('.order-line-uom');
      
      if (button && itemInput && qtyInput && uomSelect) {
        const itemId = itemInput.value || 'No Item';
        const qty = qtyInput.value || '0';
        const uomId = uomSelect.value || '';
        // Get UOM description for display
        const uomOption = availableUOMs.find(u => (u.UnitOfMeasureId || u.unitOfMeasureId) === uomId);
        const uomDisplay = uomOption ? (uomOption.Description || uomOption.description || uomId) : uomId;
        button.textContent = `Order Line ${lineIndex + 1} - ${itemId} (Qty: ${qty}, UOM: ${uomDisplay})`;
      }
    }
    
    // Remove order line
    function removeOrderLine(e) {
      if (!currentOrderData) return;
      
      const lineIndex = parseInt(e.target.dataset.lineIndex);
      const orderLines = currentOrderData.OrderLine || currentOrderData.orderLine || [];
      
      // Don't allow removing if only one line remains
      if (orderLines.length <= 1) {
        createOrderStatus.textContent = 'Cannot remove the only order line';
        createOrderStatus.className = 'text-danger';
        return;
      }
      
      if (orderLines.length > 0 && confirm(`Remove Order Line ${lineIndex + 1}?`)) {
        orderLines.splice(lineIndex, 1);
        
        // Rebuild accordion
        populateOrderLines(currentOrderData);
        
        // Update JSON editor
        updateJSONFromCurrentData();
      }
    }
    
    // Add order line after a specific index
    function addOrderLineAfter(e) {
      if (!currentOrderData) {
        createOrderStatus.textContent = 'Load an order first';
        createOrderStatus.className = 'text-danger';
        return;
      }
      
      const lineIndex = parseInt(e.target.dataset.lineIndex);
      addNewOrderLine(lineIndex);
    }
    
    // Helper function to add a new order line
    function addNewOrderLine(afterIndex) {
      const orderLines = currentOrderData.OrderLine || currentOrderData.orderLine || [];
      const defaultQty = 1;
      const newLine = {
        OrderLineId: (orderLines.length + 1).toString(),
        ItemId: '',
        OrderedQuantity: defaultQty,
        orderedQuantity: defaultQty,
        Quantity: defaultQty,
        quantity: defaultQty,
        DisplayQuantity: defaultQty,
        displayQuantity: defaultQty,
        OriginalOrderedQuantity: defaultQty,
        originalOrderedQuantity: defaultQty,
        QuantityUomId: 'units'
      };
      
      // Ensure "units" exists in available UOMs, add if not
      if (availableUOMs.length > 0 && !availableUOMs.find(u => (u.UnitOfMeasureId || u.unitOfMeasureId) === 'units')) {
        availableUOMs.push({ UnitOfMeasureId: 'units', Description: 'Units' });
      }
      
      if (afterIndex !== null && afterIndex !== undefined) {
        // Insert after the specified index
        orderLines.splice(afterIndex + 1, 0, newLine);
      } else {
        // Add to end
        orderLines.push(newLine);
      }
      
      // Rebuild accordion
      populateOrderLines(currentOrderData);
      
      // Update JSON editor
      updateJSONFromCurrentData();
      
      // Expand the new line and focus on Item ID
      const newIndex = afterIndex !== null ? afterIndex + 1 : orderLines.length - 1;
      const newLineId = `line${newIndex}`;
      const collapse = document.getElementById(newLineId);
      if (collapse) {
        const bsCollapse = new bootstrap.Collapse(collapse, { show: true });
        // Focus on Item ID input after a short delay to allow accordion to expand
        setTimeout(() => {
          const itemInput = collapse.querySelector('.order-line-item');
          if (itemInput) {
            itemInput.focus();
          }
        }, 300);
      }
    }
    
    // Sync summary field changes to JSON
    summaryOrderNumber.addEventListener('input', () => {
      if (currentOrderData) {
        const orderInput = summaryOrderNumber.value.trim();
        
        // Parse order numbers for bulk import
        const { orderNumbers, errors: parseErrors } = parseOrderNumbers(orderInput);
        
        if (parseErrors.length > 0) {
          // Show parse errors next to Create Order button
          createOrderStatus.textContent = `Parse errors: ${parseErrors.join('; ')}`;
          createOrderStatus.className = 'text-danger';
          parseErrors.forEach(err => logToConsole(err, 'error'));
          return;
        }
        
        // Clear parse errors if valid
        if (orderInput && orderNumbers.length > 0) {
          createOrderStatus.textContent = '';
        }
        
        // Store parsed order numbers for bulk import
        parsedOrderNumbers = orderNumbers;
        
        // Update current order data with first order number (for display in JSON editor)
        // The JSON editor should show the first order in the range with all OrderId fields updated
        if (orderNumbers.length > 0) {
          const firstOrderId = orderNumbers[0];
          // Update all OrderId fields recursively in the current order data
          updateAllOrderIds(currentOrderData, firstOrderId);
          logToConsole(`Updated JSON editor to show first order: ${firstOrderId}`, 'info');
        } else {
          const orderId = orderInput || currentOrderData.OrderId || currentOrderData.orderId;
          updateAllOrderIds(currentOrderData, orderId);
        }
        
        updateJSONFromCurrentData();
        
        // Log when multiple orders detected
        if (orderNumbers.length > 1) {
          logToConsole(`Multiple orders detected: ${orderNumbers.length} orders will be created using bulk API. JSON shows first order: ${orderNumbers[0]}`, 'info');
        }
      }
    });
    
    summaryOrderType.addEventListener('input', () => {
      if (currentOrderData) {
        const orderTypeValue = summaryOrderType.value.trim();
        if (!currentOrderData.OrderType) {
          currentOrderData.OrderType = orderTypeValue || '';
        }
        if (typeof currentOrderData.OrderType === 'object') {
          currentOrderData.OrderType.OrderTypeId = orderTypeValue;
          currentOrderData.OrderType.orderTypeId = orderTypeValue;
          // Also set string value for syncing
          currentOrderData.orderType = orderTypeValue;
        } else {
          currentOrderData.OrderType = orderTypeValue || '';
          currentOrderData.orderType = orderTypeValue || '';
        }
        // Sync OrderType to all order lines
        syncOrderLineFields(currentOrderData);
        updateJSONFromCurrentData();
      }
    });
    
    summaryDestinationFacility.addEventListener('input', () => {
      if (currentOrderData) {
        currentOrderData.DestinationFacilityId = summaryDestinationFacility.value;
        currentOrderData.destinationFacilityId = summaryDestinationFacility.value;
        // Sync DestinationFacilityId to all order lines
        syncOrderLineFields(currentOrderData);
        updateJSONFromCurrentData();
      }
    });
    
    summaryPickupStart.addEventListener('input', () => {
      if (currentOrderData) {
        // Convert datetime-local to ISO format
        const dateValue = summaryPickupStart.value;
        if (dateValue) {
          // datetime-local format: YYYY-MM-DDTHH:mm
          // Convert to ISO: YYYY-MM-DDTHH:mm:ss
          const isoValue = dateValue + ':00';
          currentOrderData.PickupStartDateTime = isoValue;
          currentOrderData.pickupStartDateTime = isoValue;
        } else {
          currentOrderData.PickupStartDateTime = '';
          currentOrderData.pickupStartDateTime = '';
        }
        updateJSONFromCurrentData();
      }
    });
    
    // Update JSON editor from current order data
    function updateJSONFromCurrentData() {
      if (currentOrderData && jsonEditor) {
        const jsonStr = JSON.stringify(currentOrderData, null, 2);
        jsonEditor.setValue(jsonStr);
      }
    }

    // ===== GENERIC METADATA COLLECTION =====
    let sessionId = sessionStorage.getItem('session_id');
    if (!sessionId) {
      sessionId = 'sess_' + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);
      sessionStorage.setItem('session_id', sessionId);
    }
    const pageLoadTime = new Date().toISOString();
    let authAttemptCount = 0;
    let firstAuthSuccess = true;

    // Browser detection helpers
    function getBrowserName() {
      const ua = navigator.userAgent;
      if (ua.includes('Chrome') && !ua.includes('Edg')) return 'Chrome';
      if (ua.includes('Firefox')) return 'Firefox';
      if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
      if (ua.includes('Edg')) return 'Edge';
      if (ua.includes('Opera') || ua.includes('OPR')) return 'Opera';
      return 'Unknown';
    }

    function getBrowserVersion() {
      const ua = navigator.userAgent;
      const match = ua.match(/(Chrome|Firefox|Safari|Edg|Opera|OPR)\/(\d+)/);
      return match ? match[2] : 'Unknown';
    }

    function getOSName() {
      const ua = navigator.userAgent;
      if (ua.includes('Windows')) return 'Windows';
      if (ua.includes('Mac')) return 'macOS';
      if (ua.includes('Linux')) return 'Linux';
      if (ua.includes('Android')) return 'Android';
      if (ua.includes('iOS')) return 'iOS';
      return 'Unknown';
    }

    function getOSVersion() {
      const ua = navigator.userAgent;
      if (ua.includes('Windows NT 10.0')) return '10';
      if (ua.includes('Windows NT 6.3')) return '8.1';
      if (ua.includes('Windows NT 6.2')) return '8';
      if (ua.includes('Windows NT 6.1')) return '7';
      if (ua.includes('Mac OS X')) {
        const match = ua.match(/Mac OS X (\d+[._]\d+)/);
        return match ? match[1].replace('_', '.') : 'Unknown';
      }
      return 'Unknown';
    }

    function getDeviceType() {
      const ua = navigator.userAgent;
      if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) return 'Tablet';
      if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(ua)) return 'Mobile';
      return 'Desktop';
    }

    function getCommonMetadata(eventSpecificMetadata = {}) {
      const appName = document.title.split(' v')[0] || 'Order Generator';
      const appVersionMatch = document.title.match(/v(\d+\.\d+\.\d+)/i);
      const appVersion = appVersionMatch ? appVersionMatch[1] : '1.4.7';

      const urlParams = new URLSearchParams(window.location.search);
      const urlParamsObj = {};
      for (const [key, value] of urlParams.entries()) {
        urlParamsObj[key] = value;
      }

      const currentTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'dark';
      const hasSavedPreferences = localStorage.getItem(THEME_STORAGE_KEY) !== null;

      const metadata = {
        app_name: appName,
        app_version: appVersion,
        timestamp: new Date().toISOString(),
        session_id: sessionId,
        page_load_time: pageLoadTime,
        time_on_page_seconds: Math.floor((Date.now() - new Date(pageLoadTime).getTime()) / 1000),
        user_agent: navigator.userAgent,
        browser_name: getBrowserName(),
        browser_version: getBrowserVersion(),
        device_type: getDeviceType(),
        os_name: getOSName(),
        os_version: getOSVersion(),
        screen_resolution: `${window.screen.width}x${window.screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        language: navigator.language,
        referrer: document.referrer,
        url_params: urlParamsObj,
        auto_authenticated: !!urlParams.get('Organization'),
        theme: currentTheme,
        has_saved_preferences: hasSavedPreferences,
        request_origin: window.location.origin,
        ...eventSpecificMetadata
      };

      // Add auth-specific metadata if available
      if (metadata.event_name && metadata.event_name.startsWith('auth_')) {
        metadata.auth_method = urlParams.get('Organization') ? 'url_param' : 'manual';
        metadata.auth_attempt_count = authAttemptCount;
        metadata.first_auth_success = firstAuthSuccess;
      }

      return metadata;
    }

    // Home Assistant tracking helper
    async function trackEvent(eventName, metadata = {}) {
      try {
        await api('ha-track', {
          event_name: eventName,
          metadata: getCommonMetadata(metadata)
        });
      } catch (error) {
        console.warn('[HA] Failed to track event:', error);
      }
    }

    // ===== THEME SYSTEM =====
    const themeSelectorBtn = document.getElementById('themeSelectorBtn');
    const themeModal = new bootstrap.Modal(document.getElementById('themeModal'));
    const themeList = document.getElementById('themeList');
    const THEME_STORAGE_KEY = 'order_generator_theme';
    
    // Theme definitions
    const themes = {
      dark: {
        name: 'Dark',
        rootClass: ''
      },
      manhattan: {
        name: 'Manhattan',
        rootClass: 'theme-manhattan'
      }
    };
    
    // Load saved theme or default to dark
    function loadTheme() {
      const savedTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'dark';
      applyTheme(savedTheme);
    }
    
    // Apply theme
    function applyTheme(themeName) {
      const root = document.documentElement;
      const theme = themes[themeName] || themes.dark;
      
      // Remove all theme classes
      Object.values(themes).forEach(t => {
        if (t.rootClass) {
          root.classList.remove(t.rootClass);
        }
      });
      
      // Apply selected theme
      if (theme.rootClass) {
        root.classList.add(theme.rootClass);
      }
      
      // Save to localStorage
      localStorage.setItem(THEME_STORAGE_KEY, themeName);
    }
    
    // Render theme list in modal
    function renderThemeList() {
      themeList.innerHTML = '';
      const currentTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'dark';
      
      Object.entries(themes).forEach(([key, theme]) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = `list-group-item list-group-item-action ${key === currentTheme ? 'active' : ''}`;
        item.textContent = theme.name;
        item.onclick = () => {
          applyTheme(key);
          themeModal.hide();
        };
        themeList.appendChild(item);
      });
    }
    
    // Theme selector button click handler
    if (themeSelectorBtn) {
      themeSelectorBtn.onclick = () => {
        renderThemeList();
        themeModal.show();
      };
      
      // Ensure button is always visible after theme changes
      const observer = new MutationObserver(() => {
        if (themeSelectorBtn) {
          themeSelectorBtn.style.display = 'block';
          themeSelectorBtn.style.visibility = 'visible';
        }
      });
      
      // Observe theme class changes on root element
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class']
      });
    }
    
    // Load theme on page load
    loadTheme();
    
    // Ensure gear icon is visible after theme loads
    if (themeSelectorBtn) {
      setTimeout(() => {
        themeSelectorBtn.style.display = 'block';
        themeSelectorBtn.style.visibility = 'visible';
      }, 100);
    }
  </script>
  <!-- Vercel Analytics -->
  <script>
    (function() {
      const script = document.createElement('script');
      script.src = '/_vercel/insights/script.js';
      script.defer = true;
      script.onerror = function() {
        console.warn('Vercel Analytics script failed to load. Make sure Analytics is enabled in Vercel dashboard and the app is redeployed.');
      };
      document.head.appendChild(script);
    })();
  </script>
</body>
</html>

